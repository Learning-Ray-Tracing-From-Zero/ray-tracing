#ifndef HITTABLE_H
#define HITTABLE_H

#include "ray\ray.h"

// 记录“击中”信息的结构体
struct hit_record {
	hit_record();// 构造函数
	vec3 p;// 相交点
	vec3 normal;// p 点法线
	double t;// ray 中系数 t
	bool front_face;// 判断光线从物体是否从外部射入物体（影响法线方向）

	void set_face_normal(const ray& r, const vec3& outward_normal);
};

/*
* 使用一个抽象类（含纯虚函数的类）
* 任何可能与光线求交的东西实现时都继承这个类
* 并且让球以及球列表也都继承这个类
*/
class hittable {
public:
	// 成员函数后面的 const 表示，该函数不会修改类的成员变量；由此看出只有成员函数才能如此使用
	virtual bool hit(const ray& r, double t_min, double t_max, hit_record& rec) const = 0;

};
#endif

/*
* 1、在基类中仅仅给出声明，不对虚函数实现定义，而是在派生类中实现,这个虚函数称为纯虚函数
* 2、普通函数如果仅仅给出它的声明而没有实现它的函数体，这是编译不过的,纯虚函数没有函数体
* 3、纯虚函数的实现：在函数声明之后加个 = 0
*
* 1、声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例
* 2、抽象类只能作为派生类的基类，不能定义对象，但可以定义指针
* 3、在派生类实现该纯虚函数后，定义抽象类对象的指针，并指向或引用子类对象
* 4、在定义纯虚函数时，不能定义虚函数的实现部分
* 5、在没有重新定义这种纯虚函数之前，不能调用这种函数
* 6、纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义
*
* 1、抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性
* 2、继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那么这个派生类也就成了抽象类
	 因为它继承了基类的抽象函数，只要含有纯虚函数的类就是抽象类
* 3、纯虚函数已经在抽象类中定义了这个方法的声明，其它类中只能按照这个接口去实现
*/

/*
* 接口和抽象类的区别
* 
* 1、我们一般说的接口，表示对外提供的方法，提供给外部调用，是沟通外部跟内部的桥梁
	 也是以类的形式提供的，但一般该类只具有成员函数，不具有数据成员
* 2、抽象类可以既包含数据成员又包含方法
*/