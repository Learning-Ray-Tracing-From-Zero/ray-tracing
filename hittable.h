#ifndef HITTABLE_H
#define HITTABLE_H

#include "ray.h"

struct hit_record {
	hit_record();
	vec3 p;
	vec3 normal;
	double t;
	bool front_face;

	void set_face_normal(const ray& r, const vec3& outward_normal);
};

/*
* 使用一个抽象类, 任何可能与光线求交的东西实现时都继承这个类, 并且让球以及球列表也都继承这个类
*/
class hittable {
public:

	// 成员函数后面的 const 表示，该函数不会修改类的成员变量；由此看出只有成员函数才能如此使用
	virtual bool hit(const ray& r, double t_min, double t_max, hit_record& rec) const = 0;

};
#endif

/*
* 1、在基类中仅仅给出声明，不对虚函数实现定义，而是在派生类中实现,这个虚函数称为纯虚函数
* 2、普通函数如果仅仅给出它的声明而没有实现它的函数体，这是编译不过的,纯虚函数没有函数体
* 3、纯虚函数需要在声明之后加个 = 0
*
* 1、含有纯虚函数的类被称为抽象类
* 2、抽象类只能作为派生类的基类，不能定义对象，但可以定义指针
* 3、在派生类实现该纯虚函数后，定义抽象类对象的指针，并指向或引用子类对象
* 4、在定义纯虚函数时，不能定义虚函数的实现部分
* 5、在没有重新定义这种纯虚函数之前，不能调用这种函数
*
* 1、抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性
* 2、继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那么这个派生类也就成了抽象类
	 因为它继承了基类的抽象函数，只要含有纯虚函数的类就是抽象类
* 3、纯虚函数已经在抽象类中定义了这个方法的声明，其它类中只能按照这个接口去实现
*/

/*
* 接口和抽象类的区别
* 
* 1、我们一般说的接口，表示对外提供的方法，提供给外部调用，是沟通外部跟内部的桥梁
	 也是以类的形式提供的，但一般该类只具有成员函数，不具有数据成员
* 2、抽象类可以既包含数据成员又包含方法
*/
